安装vscode插件-live server，实现同步刷新

引入外部文件在标签体内的脚本不会执行，下面的alert弹窗不会执行。
<script src="houdunren.js">
	alert('houdunren.com');
</script>

在使用构建工具时，不使用分号结束可能会造成异常

typeof ()等价于 typeof ..
typeof返回结果全部小写
typeof把null和正则表达式标识为"object"、function标识为"function"，其他正常表示
typeof 判断未声明变量时，依然会给出"undefined"

a=2,b=2 不等价于 a,b=2，后者a没有赋值

解析器会先解析代码，然后把声明的变量的声明提升到最前，这就叫做变量提升。

下面是 if(false) 中定义的var也会发生变量提升，注释掉if 结果会不同
var web = "houdunren";
function hd() {
  if (false) {
    var web = "后盾人";
  }
  console.log(web);
}
hd();

TDZ 又称暂时性死区，指变量在作用域内已经存在，但必须在let/const声明后才可以使用。

function hd(a = b, b = 3) {}
hd(); //Cannot access 'b' before initialization

因为a已经赋值，所以b可以使用a变量，下面代码访问正常
function hd(a = 2, b = a) {}
hd(); 

var 全局声明的变量也存在于 window对象中
var hd = "houdunren";
console.log(window.hd); //houdunren

const不能第二次赋值，但是可以改变引用类型的值

let 全局声明的变量不存在于 window对象中，这与var声明不同

Object.freeze可以冻结变量，利用这个函数可以解决const的引用可以被改变问题

Object.freeze
如果冻结变量后，变量也不可以修改了，使用严格模式会报出错误。

传值与传址
基本数据类型指数值、字符串等简单数据类型，引用类型指对象数据类型。

对声明但未赋值的变量返回类型为 undefined 表示值未定义。
对未声明的变量使用会报错，但判断类型将显示 undefined。

function hd(web) {
  console.log(web); //undefined，因为上面的形参以及被声明了
  return web;
}
console.log(hd()); //undefined

主流框架都采用严格模式，严格模式也是未来JS标准，所以建议代码使用严格模式开发

单独为函数设置严格模式
function strict(){  
  "use strict";  
  return "严格模式";  
}  
function notStrict() {  
  return "正常模式";  
}  

解构差异
非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明。

// "use strict";
({name,url} = {name:'后盾人',url:'houdunren.com'});
console.log(name, url);

%	取余数

n*=2 等同于 n=n*2

前置操作会在表达式最先执行。
后置操作会在表达式最后执行。

!!"a" == true 这是对的
"a" == true 这是错的

a = 1,b = "0"
a > b 这是对的

==	强制类型转换比较
===	不强制类型转换比较

使用 && 符号表示逻辑与，指符号两端都为 true 时表达式结果为true。
使用 || 符号表示逻辑或，指符号左右两端有一方为true，表达式即成立。

&& 优先级高于 ||

短路运算
let sex = prompt("你的性别是？") || "保密";

下面例子缺少break 后，会接着执行后面的switch代码。
switch (1) {
  case 1:
    console.log(1);
  case 2:
    console.log(2);
  default:
    console.log("default");
}

do.while和while区别就是，前者多执行一次

break用于退出当前循环，continue用于退出当前循环返回循环起始继续执行。

label
标签(label) 为程序定义位置，可以使用continue/break跳到该位置。

for in可以用来遍历对象和数组

for/of
用来遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构。

与 for/in 不同的是 for/of 每次循环取其中的值而不是索引。

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
instanceof可以区分数组和正则
typeof 可以区分非null基本数据类型和function
Object.prototype.toString.call()可以区分全部类型

只有对象才有方法使用，但在JS中也可以使用值类型调用方法，因为它会在执行时将值类型转为对象。
let hd = "houdunren";
let cms = new String("hdcms");
console.log(hd.length); //9
console.log(cms.length); //5

"\\" => \

将字符转换成大写格式
console.log('houdunren.com'.toUpperCase()); //HOUDUNREN.COM
转字符为小写格式
console.log('houdunren.com'.toLowerCase()); //houdunren.com

移除空白
使用trim删除字符串左右的空白字符

使用trimLeft删除左边空白，使用trimRight删除右边空白

获取单字符
根据从0开始的位置获取字符
console.log('houdunren'.charAt(3))
使用数字索引获取字符串
console.log('houdunren'[3])

截取字符串
使用 slice、substr、substring 函数都可以截取字符串。
slice、substring 第二个参数为截取的结束位置，但slice可以是负数
substr 第二个参数指定获取字符数量

查找字符串
从开始获取字符串位置，检测不到时返回 -1
console.log('houdunren.com'.indexOf('o')); //1
console.log('houdunren.com'.indexOf('o', 3)); //11 从第3个字符向后搜索

从结尾来搜索字符串位置
console.log('houdunren.com'.lastIndexOf('o')); //11
console.log('houdunren.com'.lastIndexOf('o', 7)); //1 从第7个字符向前搜索

search() 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索，找到就不继续了，找不到返回-1

includes 字符串中是否包含指定的值，第二个参数指查找开始位置
console.log('houdunren.com'.includes('o')); //true
console.log('houdunren.com'.includes('h', 11)); //true

startsWith（endsWith） 是否是指定位置开始，第二个参数为查找的开始位置。
console.log('houdunren.com'.startsWith('h')); //true
console.log('houdunren.com'.startsWith('o', 1)); //true

replace 方法用于字符串的替换操作，默认只替换一次，如果全局替换需要使用正则
let name = "houdunren.com";
web = name.replace("houdunren", "hdcms");
console.log(web);

分隔字母
let name = "hdcms";
console.log(name.split(""));

数据类型	true	false
String	非空字符串	空字符串
Number	非0的数值	0 、NaN
Array	数组不参与比较时	参与比较的空数组
Object	所有对象	
undefined	无	undefined
null	无	null
NaN	无	NaN

null和NAN直接进行布尔判断及不等于true，也不等于false，只有类型转换之后，全部都是false

Symbol()也不能直接判断，!!Symbol() == true

判断是否为整数
console.log(Number.isInteger(1.2));

指定返回的小数位数可以四舍五入,参数超过补0
console.log((16.556).toFixed(2)); // 16.56

NaN不能使用 == 比较，使用以下代码来判断结果是否正确
var res = 2 / 'houdunren';
if (Number.isNaN(res)) {
	console.log('Error');
}

也可以使用 Object.is 方法判断两个值是否完全相同
var res = 2 / 'houdunren';
console.log(Object.is(res, NaN));

大部分编程语言在浮点数计算时都会有精度误差问题，下面来看JS中的表现形式

let hd = 0.1 + 0.2
console.log(hd)// 结果：0.30000000000000004

舍入处理
取最接近的向上整数
console.log(Math.ceil(1.111)); //2
得到最接近的向下整数
console.log(Math.floor(1.555)); //1
四舍五入处理
console.log(Math.round(1.5)); //2

random 方法用于返回 >=0 且 <1 的随机数（包括0但不包括1）。

let now = new Date();
console.log(now * 1); //获取时间戳

//直接使用函数获取当前时间
console.log(Date());

//获取当前时间戳单位毫秒
console.log(Date.now());

let now = new Date('2028-02-22 03:25:02');
console.log(now);
now = new Date(2028, 4, 5, 1, 22, 16);
console.log(now);

将日期转为数值类型就是转为时间戳单位是毫秒
+(new Date()) => 1594126205896

有时后台提供的日期为时间戳格式，下面是将时间戳转换为标准日期的方法
const param = [1990, 2, 22, 13, 22, 19];
const date = new Date(...param);
const timestamp = date.getTime();
console.log(timestamp);
console.log(new Date(timestamp));

格式化输出日期

let time = new Date();
console.log(
  `${time.getFullYear()}-${time.getMonth()}-${time.getDate()} ${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}`
);

(new Date).getMonth()得到的是一个从0开始的数，也就是得+1，才得到真实月份

getDay是获取周数，getTime是获取时间戳，getDate是获取号数

setTime()	以毫秒设置 Date 对象。

toString()	把 Date 对象转换为字符串。

toLocaleString()	根据本地时间格式，把 Date 对象转换为字符串。获得"1970/1/1 上午8:00:00"
toLocaleTimeString()	根据本地时间格式，把 Date 对象的时间部分转换为字符串。获得"上午8:00:00"
toLocaleDateString()	根据本地时间格式，把 Date 对象的日期部分转换为字符串。获得"1970/1/1"

moment.js
Moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率。

声明多个空元素的数组
let hd = new Array(3);
console.log(hd.length);
console.log(hd);

注意Array.is(3)和 new Array(3)的区别

Array.of
使用Array.of 与 new Array 不同是设置一个参数时不会创建空元素数组
let hd = Array.of(3);
console.log(hd); //[3]
hd = Array.of(1, 2, 3);
console.log(hd); //[1, 2, 3]

检测变量是否为数组类型
console.log(Array.isArray([1, "后盾人", "hdcms"])); //true
console.log(Array.isArray(9)); //false

使用join连接为字符串
console.log([1, 2, 3].join("-"));//1-2-3

Array.from
使用Array.from可将类数组转换为数组，类数组指包含 length 属性或可迭代的对象。
第一个参数为要转换的数据，第二个参数为类似于map 函数的回调方法，若不提供第二个参数，则返回数组，否则返回map得到的数组
let str = '后盾人';
console.log(Array.from(str)); //["后", "盾", "人"]

为对象设置length属性后也可以转换为数组，但要下标为数值或数值字符串
let user = {
  0: '后盾人',
  '1': 18,
  length: 2
};
console.log(Array.from(user)); //["后盾人", 18]

DOM元素转换为数组后来使用数组函数，第二个参数类似于map 函数的方法，可对数组元素执行函数处理。

为对象设置length属性后也可以转换为数组，但要下标为数值或数值字符串

a = "12345"
[...a] => ["1", "2", "3", "4", "5"]

数组合并
使用展开语法来合并数组相比 concat 要更简单，使用... 可将数组展开为多个值。
let a = [1, 2, 3];
let b = ['a', '后盾人', ...a];
console.log(b); //["a", "后盾人", 1, 2, 3]

push
压入元素，直接改变元数组，返回值为数组元素数量

pop
从末尾弹出元素，直接改变元数组，返回值为弹出的元素

shift
从数组前面取出一个元素,返回该元素

unshift
从数组前面添加元素，返回长度

fill
使用fill 填充数组元素
console.dir(Array(4).fill("后盾人")); //["后盾人", "后盾人", "后盾人", "后盾人"]
指定填充位置
console.log([1, 2, 3, 4].fill("后盾人", 1, 2)); //[1, "后盾人", 3, 4]

splice
使用 splice 方法可以添加、删除、替换数组中的元素，会对原数组进行改变，返回值为删除的元素。
第一个参数是初始位置，第二个参数是长度，第三个参数之后的所有元素是替换元素，替换指定位置左边的元素

清空数组方法：
1. arr.length = 0
2. arr.splice(0,arr.length)

copyWithin
使用 copyWithin 从数组中复制一部分到同数组中的另外位置。
语法说明
array.copyWithin(target, start, end)
const arr = [1, 2, 3, 4];
console.log(arr.copyWithin(2, 0, 2)); //[1, 2, 1, 2]

includes
使用 includes 查找字符串返回值是布尔类型更方便判断
使用includes等不能查找引用类型，因为它们的内存地址是不相等的

find 方法找到后会把值返回出来
如果找不到返回值为undefined
返回第一次找到的值，不继续查找
let arr = ["hdcms", "houdunren", "hdcms"];
let find = arr.find(function(item) {
  return item == "hdcms";
});
console.log(find); //hdcms

find 可以方便的查找引用类型
const user = [{ name: "李四" }, { name: "张三" }, { name: "后盾人" }];
const find = user.find(user => (user.name = "后盾人"));
console.log(find);

findIndex
findIndex 与 find 的区别是返回索引值，参数也是 : 当前值，索引，操作数组。

reverse反转数组顺序

arr.sort((a,b)=>a-b) 升序
arr.sort((a,b)=>b-a) 倒序

数组遍历for、for in、forEach、for of

使用数组的迭代对象遍历获取索引与值（有关迭代器知识后面章节会讲到）
const hd = ['houdunren', 'hdcms'];
const iterator = hd.entries();
console.log(iterator.next()); //value:{0:0,1:'houdunren'}
console.log(iterator.next()); //value:{0:1,1:'hdcms'}
这样就可以使用解构特性与 for/of 遍历并获取索引与值了
const hd = ["hdcms", "houdunren"];
for (const [key, value] of hd.entries()) {
  console.log(key, value); //这样就可以遍历了
}

keys和values是数组的迭代器方法

entries
返回数组所有键值对，下面使用解构语法循环

every
every 用于递归的检测元素，要所有元素操作都要返回真结果才为真。

some
使用 some 函数可以递归的检测元素，如果有一个返回true，表达式结果就是真。第一个参数为元素，第二个参数为索引，第三个参数为原数组。

filter
使用 filter 可以过滤数据中元素，返回回调函数返回true的元素组成的数组

reduce
使用 reduce 与 reduceRight 函数可以迭代数组的所有元素，reduce 从前开始 reduceRight 从后面开始。下面通过函数计算课程点击数的和。
第一个参数是执行函数，第二个参数为初始值
传入第二个参数时将所有元素循环一遍
不传第二个参数时从第二个元素开始循环
函数参数说明如下
参数	说明
prev	上次调用回调函数返回的结果
cur	当前的元素值
index	当前的索引
array	原数组

Symbol 不可以添加属性

使用description可以获取传入的描述参数
let hd = Symbol("后盾人");
console.log(hd.description); //后盾人

Symbol.for
根据描述获取Symbol，如果不存在则新建一个Symbol

使用Symbol.for会在系统中将Symbol登记
使用Symbol则不会登记
let hd = Symbol.for("后盾人");
let edu = Symbol.for("后盾人");
console.log(hd == edu); //true

Symbol.keyFor
Symbol.keyFor 根据使用Symbol.for登记的Symbol返回描述，如果找不到返回undefined 。

正确写法是以[] 变量形式声明和访问
let symbol = Symbol("后盾人");
let obj = {
  [symbol]: "houdunren.com"
};
console.log(obj[symbol]); //houdunren.com

使用Symbol可以解决在保存数据时由于名称相同造成的耦合覆盖问题。
class Cache {
  static data = {};
  static set(name, value) {
    this.data[name] = value;
  }
  static get(name) {
    return this.data[name];
  }
}
let user = {
  name: "后盾人",
  key: Symbol("缓存")
};
let cart = {
  name: "购物车",
  key: Symbol("购物车")
};
Cache.set(user.key, user);
Cache.set(cart.key, cart);
console.log(Cache.get(user.key));

遍历属性
Symbol 不能使用 for/in、for/of 遍历操作

可以使用 Object.getOwnPropertySymbols 获取所有Symbol属性
也可以使用 Reflect.ownKeys(obj) 获取所有自身属性包括Symbol和不可遍历属性

Symbol
Symbol用于防止属性名冲突而产生的，比如向第三方对象中添加属性时。
Symbol 的值是唯一的，独一无二的不会重复的



Set
用于存储任何类型的唯一值，无论是基本类型还是对象引用。
只能保存值没有键名
严格类型检测如字符串数字不等于数值型数字
值是唯一的
遍历顺序是添加的顺序，方便保存回调函数

Set.prototype.size
Set.prototype.add 支持链式操作
Set.prototype.delete
Set.prototype.values 它是一个迭代器
Set.prototype.has
Set.prototype.clear 删除所有元素

可以使用点语法 或 Array.from 静态方法将Set类型转为数组，这样就可以使用数组处理函数了
const set = new Set(["hdcms", "houdunren"]);
console.log([...set]); //["hdcms", "houdunren"]
console.log(Array.from(set)); //["hdcms", "houdunren"]

使用 keys()/values()/entries() 都可以返回迭代对象，因为set类型只有值所以 keys与values 方法结果一致。

可以使用 forEach 遍历Set数据，默认使用 values 方法创建迭代器。

为了保持和遍历数组参数统一，函数中的value与key是一样的。
let arr = [7, 6, 2, 8, 2, 6];
let set = new Set(arr);
//使用forEach遍历
set.forEach((item,key) => console.log(item,key));
这里的item和key值都是value，一样的

//使用for/of遍历
let set = new Set([7, 6, 2, 8, 2, 6]);
for (const iterator of set) {
	console.log(iterator);
}

原型是用来供实例搜索的，类本身不会遍历原型

WeakSet
WeakSet结构同样不会存储重复的值，它的成员必须只能是对象类型的值。
垃圾回收不考虑WeakSet，即被WeakSet引用时引用计数器不加一，所以对象不被引用时不管WeakSet是否在使用都将删除
因为WeakSet 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行forEach( )遍历等操作
也是因为弱引用，WeakSet 结构没有keys( )，values( )，entries( )等方法和size属性
因为是弱引用所以当外部引用删除时，希望自动删除数据时使用 WeakMap

垃圾回收
WeakSet保存的对象不会增加引用计数器，如果一个对象不被引用了会自动删除。
下例中的数组被 arr 引用了，引用计数器+1
数据又添加到了 hd 的WeaSet中，引用计数还是1
当 arr 设置为null时，引用计数-1 此时对象引用为0
当垃圾回收时对象被删除，这时WakeSet也就没有记录了

由于WeakSet不能时引用计时器+1特性，所以不能使用forEach，keys，values，entries

Map
Map是一组键值对的结构，用于解决以往不能用对象做为键的问题
具有极快的查找速度
函数、对象、基本类型都可以作为键或值
可以接受一个数组作为参数，该数组的成员是一个表示键值对的数组。
let m = new Map([
  ['houdunren', '后盾人'],
  ['hdcms', '开源系统']
]);
console.log(m.get('houdunren')); //后盾人

使用set 方法添加元素，支持链式操作

对于键是对象的Map， 键保存的是内存地址，值相同但内存地址不同的视为两个键。
let arr = ["后盾人"];
const hd = new Map();
hd.set(arr, "houdunren.com");
console.log(hd.get(arr)); //houdunren.com
console.log(hd.get(["后盾人"])); //undefined

获取数据数量
console.log(map.size);

检测元素是否存在
console.log(map.has(obj1));

使用 delete() 方法删除单个元素

使用clear方法清除Map所有元素

使用 keys()/values()/entries() 都可以返回可遍历的迭代对象。
let hd = new Map([["houdunren", "后盾人"], ["hdcms", "开源系统"]]);
console.log(hd.keys()); //MapIterator {"houdunren", "hdcms"}
console.log(hd.values()); //MapIterator {"后盾人", "开源系统"}
console.log(hd.entries()); //MapIterator {"houdunren" => "后盾人", "hdcms" => "开源系统"}
注意和set的区别，set不管keys，values还是entries都返回value

使用for/of遍历操作，直播遍历Map 等同于使用entries() 函数

let hd = new Map([["houdunren", "后盾人"], ["hdcms", "开源系统"]]);
for (const [key, value] of hd) {
  console.log(`${key}=>${value}`);
}

可以使用展开语法 或 Array.from 静态方法将Set类型转为数组，这样就可以使用数组处理函数了
let hd = new Map([["houdunren", "后盾人"], ["hdcms", "开源系统"]]);
console.log(...hd); //(2) ["houdunren", "后盾人"] (2) ["hdcms", "开源系统"]
console.log(...hd.entries()); //(2) ["houdunren", "后盾人"] (2) ["hdcms", "开源系统"]
console.log(...hd.values()); //后盾人 开源系统
console.log(...hd.keys()); //houdunren hdcms

map的key可以为任意类型，下面使用DOM节点做为键来记录数据。

WeakMap
WeakMap 对象是一组键/值对的集
键名必须是对象
WeaMap对键名是弱引用的，键值是正常引用
垃圾回收不考虑WeaMap的键名，不会改变引用计数器，键在其他地方不被引用时即删除
因为WeakMap 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行forEach( )遍历等操作
也是因为弱引用，WeaMap 结构没有keys( )，values( )，entries( )等方法和 size 属性
当键的外部引用删除时，希望自动删除数据时使用 WeakMap

下面是WeakSet的常用指令

const hd = new WeakMap();
const arr = ["hdcms"];
//添加操作
hd.set(arr, "houdunren");
console.log(hd.has(arr)); //true
//删除操作
hd.delete(arr);
//检索判断
console.log(hd.has(arr)); //false

function A(){}这个在全局声明会作为window属性保存
使用let/const时不会压入window

let和function同时声明时，let会先被提到代码顶端，function在let弄好之后，才提升
因此：
function a(){}
let a;
此时的a是function而不是undefined

标准声明优先级高于赋值声明
console.log(hd(3)); //4
function hd(num) {
  return ++num;
}
var hd = function() {
  return "hd";
};

立即执行函数指函数定义时立即执行
可以用来定义私有作用域防止污染全局作用域
"use strict";
(function () {
    var web = 'houdunren';
})();
console.log(web); //web is not defined
使用 let/const 有块作用域特性，所以使用以下方式也可以产生私有作用域
{
	let web = 'houdunren';
}
console.log(web);

形参数量大于实参时，没有传参的形参值为 undefined
实参数量大于形参时，多于的实参将忽略并不会报错

函数参数
函数可以做为参数传递，这也是大多数语言都支持的语法规则。

arguments获取所有实参集合，而不是形参集合
arguments伪数组

标签函数
使用函数来解析标签字符串，第一个参数是字符串值的数组，其余的参数为标签变量。
function hd(str, ...values) {
  console.log(str); //["站点", "-", "", raw: Array(3)]
  console.log(values); //["后盾人", "houdunren.com"]
}
let name = '后盾人',url = 'houdunren.com';
hd `站点${name}-${url}`;

全局环境下this就是window对象的引用
使用严格模式时在全局函数内this为undefined
在全局作用域打印this依然是window

方法调用
函数为对象的方法时this 指向该对象


课程代码 
基础知识
运算符与流程控制
基本类型
数组类型
Symbol
Set
Map
函数进阶
基础知识
声明定义
匿名函数
立即执行
函数提升
形参实参
默认参数
函数参数
arguments
箭头函数
递归调用
回调函数
展开语法
标签函数
this
函数调用
方法调用
箭头函数
apply/call/bind
原理分析
apply/call
bind
作用域与闭包
对象
原型与继承
类
模块设计
正则表达式
Promise
任务管理
Promise核心
DOM
空间坐标
事件
网络请求
#基础知识
houdunren.com @ 向军大叔

函数是将复用的代码块封装起来的模块，在JS中函数还有其他语言所不具有的特性，接下来我们会详细掌握使用技巧。

#声明定义
在JS中函数也是对象函数是Function类的创建的实例，下面的例子可以方便理解函数是对象。

let hd = new Function("title", "console.log(title)");
hd('后盾人');

标准语法是使用函数声明来定义函数

function hd(num) {
	return ++num;
}
console.log(hd(3));

对象字面量属性函数简写

let user = {
  name: null,
  getName: function (name) {
  	return this.name;
  },
  //简写形式
  setName(value) {
  	this.name = value;
  }
}
user.setName('后盾人');
console.log(user.getName()); // 后盾人

全局函数会声明在window对象中，这不正确建议使用后面章节的模块处理

console.log(window.screenX); //2200

当我们定义了 screenX 函数后就覆盖了window.screenX方法

function screenX() {
  return "后盾人";
}
console.log(screenX()); //后盾人

使用let/const时不会压入window

let hd = function() {
  console.log("后盾人");
};
window.hd(); //window.hd is not a function

#匿名函数
函数是对象所以可以通过赋值来指向到函数对象的指针，当然指针也可以传递给其他变量，注意后面要以;结束。下面使用函数表达式将 匿名函数 赋值给变量

let hd = function(num) {
  return ++num;
};

console.log(hd instanceof Object); //true

let cms = hd;
console.log(cms(3));

标准声明的函数优先级更高，解析器会优先提取函数并放在代码树顶端，所以标准声明函数位置不限制，所以下面的代码可以正常执行。

console.log(hd(3));
function hd(num) {
	return ++num;
};

标准声明优先级高于赋值声明

console.log(hd(3)); //4

function hd(num) {
  return ++num;
}

var hd = function() {
  return "hd";
};

程序中使用匿名函数的情况非常普遍

function sum(...args) {
  return args.reduce((a, b) => a + b);
}
console.log(sum(1, 2, 3));

#立即执行
立即执行函数指函数定义时立即执行

可以用来定义私有作用域防止污染全局作用域
"use strict";
(function () {
    var web = 'houdunren';
})();
console.log(web); //web is not defined

使用 let/const 有块作用域特性，所以使用以下方式也可以产生私有作用域

{
	let web = 'houdunren';
}
console.log(web);

#函数提升
函数也会提升到前面，优先级行于var变量提高

console.log(hd()); //后盾人
function hd() {
	return '后盾人';
}

变量函数定义不会被提升

console.log(hd()); //后盾人

function hd() {
	return '后盾人';
}
var hd = function () {
	return 'hdcms.com';
}

#形参实参
形参是在函数声明时设置的参数，实参指在调用函数时传递的值。

形参数量大于实参时，没有传参的形参值为 undefined
实参数量大于形参时，多于的实参将忽略并不会报错
// n1,n2 为形参
function sum(n1, n2) {
	return n1+n2;
}
// 参数 2,3 为实参
console.log(sum(2, 3)); //5

当没传递参数时值为undefined

function sum(n1, n2) {
  return n1 + n2;
}
console.log(sum(2)); //NaN

#默认参数
下面通过计算年平均销售额来体验以往默认参数的处理方式

//total:总价 year:年数
function avg(total, year) {
  year = year || 1;
  return Math.round(total / year);
}
console.log(avg(2000, 3));

使用新版本默认参数方式如下

function avg(total, year = 1) {
  return Math.round(total / year);
}
console.log(avg(2000, 3));

下面通过排序来体验新版默认参数的处理方式，下例中当不传递 type 参数时使用默认值 asc。

function sortArray(arr, type = 'asc') {
	return arr.sort((a, b) => type == 'asc' ? a - b : b - a);
}
console.log(sortArray([1, 3, 2, 6], 'desc'));

默认参数要放在最后面

//total:价格,discount:折扣,dis:折后折
function sum(total, discount = 0, dis = 0) {
  return total * (1 - discount) * (1 - dis);
}
console.log(sum(2000, undefined, 0.3));

#函数参数
函数可以做为参数传递，这也是大多数语言都支持的语法规则。

<body>
    <button>订阅</button>
</body>
<script>
    document.querySelector('button').addEventListener('click', function () {
        alert('感谢订阅');
    })
</script>

函数可以做为参数传递

function filterFun(item) {
	return item <= 3;
}
let hd = [1, 2, 3, 4, 5].filter(filterFun);
console.log(hd); //[1,2,3]

#arguments
arguments 是函数获得到所有参数集合，下面是使用 arguments 求和的例子

function sum() {
  return [...arguments].reduce((total, num) => {
    return (total += num);
  }, 0);
}
console.log(sum(2, 3, 4, 2, 6)); //17

更建议使用展示语法

function sum(...args) {
 return args.reduce((a, b) => a + b);
}
console.log(sum(2, 3, 4, 2, 6)); //17

#箭头函数
箭头函数是函数声明的简写形式，在使用递归调用、构造函数、事件处理器时不建议使用箭头函数。

无参数时使用空扩号即可

let sum = () => {
	return 1 + 3;
}
console.log(sum()); //4

函数体为单一表达式时不需要 return 返回处理，系统会自动返回表达式计算结果。

let sum = () => 1 + 3;
console.log(sum()); //4

多参数传递与普通声明函数一样使用逗号分隔

let hd = [1, 8, 3, 5].filter((item, index) => {
	return item <= 3;
});
console.log(hd);

只有一个参数时可以省略括号

let hd = [1, 8, 3, 5].filter(item => item <= 3);
console.log(hd);

有关箭头函数的作用域知识会在后面章节讨论

#递归调用
递归指函数内部调用自身的方式。

主要用于数量不确定的循环操作
要有退出时机否则会陷入死循环
下面通过阶乘来体验递归调用

function factorial(num = 3) {
	return num == 1 ? num : num * factorial(--num);
}
console.log(factorial(5)); //120

累加计算方法

function sum(...num) {
	return num.length == 0 ? 0 : num.pop() + sum(...num);
}
console.log(sum(1, 2, 3, 4, 5, 7, 9)); //31

递归打印倒三角

******
*****
****
***
**
*

function star(row = 5) {
  if (row == 0) return "";
  document.write("*".repeat(row) + "<br/>");
  star(--row);
}

使用递归修改课程点击数

let lessons = [
  {
    title: "媒体查询响应式布局",
    click: 89
  },
  {
    title: "FLEX 弹性盒模型",
    click: 45
  },
  {
    title: "GRID 栅格系统",
    click: 19
  },
  {
    title: "盒子模型详解",
    click: 29
  }
];
function change(lessons, num, i = 0) {
  if (i == lessons.length) {
    return lessons;
  }
  lessons[i].click += num;
  return change(lessons, num, ++i);
}
console.table(change(lessons, 100));

#回调函数
在某个时刻被其他函数调用的函数称为回调函数，比如处理键盘、鼠标事件的函数。

<button id='hd'>button</button>
<script>
     document.getElementById('hd').addEventListener('click', () => alert('通过回调函数调用'));
</script>

使用回调函数递增计算

let hd = ([1, 2, 3]).map(item => item + 10);
console.log(hd)

#展开语法
展示语法或称点语法体现的就是收/放特性，做为值时是放，做为接收变量时是收。

let hd = [1, 2, 3];
let [a, b, c] = [...hd];
console.log(a); //1
console.log(b); //2
console.log(c); //3
[...hd] = [1, 2, 3];
console.log(hd); //[1, 2, 3]

使用展示语法可以替代 arguments 来接收任意数量的参数

function hd(...args) {
  console.log(args);
}
hd(1, 2, 3, "后盾人"); //[1, 2, 3, "后盾人"]

也可以用于接收部分参数

function hd(site, ...args) {
  console.log(site, args); //后盾人 (3) [1, 2, 3]
}
hd("后盾人", 1, 2, 3);

使用 ... 可以接受传入的多个参数合并为数组，下面是使用点语法进行求合计算。

function sum(...params) {
	console.log(params);
	return params.reduce((pre, cur) => pre + cur);
}
console.log(sum(1, 3, 2, 4));

多个参数时...参数必须放后面，下面计算购物车商品折扣

function sum(discount = 0, ...prices) {
  let total = prices.reduce((pre, cur) => pre + cur);
  return total * (1 - discount);
}
console.log(sum(0.1, 100, 300, 299));

#标签函数
使用函数来解析标签字符串，第一个参数是字符串值的数组，其余的参数为标签变量。

function hd(str, ...values) {
  console.log(str); //["站点", "-", "", raw: Array(3)]
  console.log(values); //["后盾人", "houdunren.com"]
}
let name = '后盾人',url = 'houdunren.com';
hd `站点${name}-${url}`;

#this
调用函数时 this 会隐式传递给函数指函数调用时的关联对象，也称之为函数的上下文。

#函数调用
全局环境下this就是window对象的引用

<script>
  console.log(this == window); //true
</script>

使用严格模式时在全局函数内this为undefined

var hd = '后盾人';
function get() {
  "use strict"
  return this.hd;
}
console.log(get());
//严格模式将产生错误 Cannot read property 'name' of undefined

#方法调用
函数为对象的方法时this 指向该对象
可以使用多种方式创建对象，下面是使用构造函数创建对象
构造函数
函数当被 new 时即为构造函数，一般构造函数中包含属性与方法。函数中的上下文指向到实例对象。
构造函数主要用来生成对象，里面的this默认就是指当前对象

this会自动寻找调用该方法的对象，而不会向上捕获
箭头函数没有自己的this，会找父函数的this，该this是调用父方法的对象，而不是定义时的对象，若父函数没有this，则返回window对象，若父函数也是箭头函数，又会向上一层继续寻找this

箭头函数
箭头函数没有this, 也可以理解为箭头函数中的this 会继承定义函数时的上下文，可以理解为和外层函数指向同一个this。

apply/call/bind
改变this指针，也可以理解为对象借用方法，就现像生活中向邻居借东西一样的事情。
apply第二个参数是数组
call则不是数组，有n个参数
bind第二个参数是数组，但是返回的是函数，不会立即执行

作用域链只向上查找，找到全局window即终止，应该尽量不要在全局作用域中添加变量。

如果子函数被使用时父级环境将被保留

构造函数也是很好的环境例子，子函数被外部使用父级环境将被保留

在 for 循环中使用let/const 会在每一次迭代中重新生成不同的变量
let arr = [];
for (let i = 0; i < 10; i++) {
	arr.push((() => i));
}
console.log(arr[3]()); //3 如果使用var声明将是10

在没有let/const 的历史中使用以下方式产生作用域

//自行构建闭包
var arr = [];
for (var i = 0; i < 10; i++) {
  (function (a) {
      arr.push(()=>a);
  })(i);
}
console.log(arr[3]()); //3

闭包使用
闭包指子函数可以访问外部作用域变量的函数特性，即使在子函数作用域外也可以访问。如果没有闭包那么在处理事件绑定，异步请求时都会变得困难。
JS中的所有函数都是闭包
闭包一般在子函数本身作用域以外执行，即延伸作用域

闭包特性中上级作用域会为函数保存数据，从而造成的如下所示的内存泄漏问题

下面通过清除不需要的数据解决内存泄漏问题
let divs = document.querySelectorAll("div");
divs.forEach(function(item) {
  let desc = item.getAttribute("desc");
  item.addEventListener("click", function() {
    console.log(desc);
  });
  item = null;
});

回调函数也是一个闭包

其实字面量形式在系统内部也是使用构造函数 new Object创建的，后面会详细介绍构造函数。

obj.name 的 name就是字符串，如果name是变量比如：
var name = "test";
obj若要访问name的值必须obj[name]，或obj.test

如果属性名不是合法变量名就必须使用扩号的形式了
let user = {};
user["my-age"] = 28;
console.log(user["my-age"]);

delete 可以删除的对象：
1. 不声明直接赋值的变量如：
a = 1;delete a; // true
2. 对象的属性和方法,包含对象的原型上的属性和方法

使用...可以展示对象的结构，下面是实现对象合并的示例
let hd = { name: "后盾人", web: "houdurnen.com" };
let info = { ...hd, site: "hdcms" };
console.log(info);

对象有valueOf和toString方法
对象直接参与计算时，系统会根据计算的场景在 string/number/default 间转换。
如果声明需要字符串类型，调用顺序为 toString > valueOf
如果场景需要数值类型，调用顺序为 valueOf > toString
声明不确定时使用 default ，大部分对象的 default 会当数值使用
下面的数值对象会在数学运算时转换为 number
let houdunren = new Number(1);
console.log(houdunren + 3); //4
如果参数字符串运长时会转换为 string
let houdunren = new Number(1);
console.log(houdunren + "3"); //13

Symbol.toPrimitive
内部自定义Symbol.toPrimitive方法用来处理所有的转换场景
let hd = {
  num: 1,
  [Symbol.toPrimitive]: function() {
    return this.num;
  }
};
console.log(hd + 3); //4

valueOf/toString
可以自定义valueOf 与 toString 方法用来转换，转换并不限制返回类型。
let hd = {
  name: "后盾人",
  num: 1,
  valueOf: function() {
    console.log("valueOf");
    return this.num;
  },
  toString: function() {
    console.log("toString");
    return this.name;
  }
};
console.log(hd + 3); //valueOf 4
console.log(`${hd}向军`); //toString 后盾人向军

js中大多数类型都是对象，当进行运算时，对象会通过valueOf和toString进行返回运算值，当然也可以通过Symbol.toPrimitive方法来返回参与运算的值

非严格模式可以不使用声明指令，严格模式下必须使用声明。所以建议使用 let 等声明。

可以操作多层复杂数据结构

const hd = {
  name:'后盾人',
  lessons:{
    title:'JS'
  }
}
const {name,lessons:{title}}  = hd;
console.log(name,title); //后盾人 JS

为变量设置默认值
let [name, site = 'hdcms'] = ['后盾人'];

使用默认值特性可以方便的对参数预设
function createElement(options) {
  let {
    width = '200px',
    height = '100px',
    backgroundColor = 'red'
  } = options;

数组参数的使用
function hd([a, b]) {
	console.log(a, b);
}
hd(['后盾人', 'hdcms']);

const hd = {
  name:'后盾人',
  lessons:{
    title:'JS'
  }
}
const {name,lessons:{title}}  = hd;
// 这里只得到了name和title，而lessons没有得到

可以利用结构应付函数参数为各种类型数据，比如对象，数组

检测属性
hasOwnProperty检测对象自身是否包含指定的属性，不检测原型链上继承的属性。

使用 in 可以在原型对象上检测

用 Object.assign 静态方法
从一个或多个对象复制属性，包含自身和原型的，但是它属于浅拷贝

计算属性
对象属性可以通过表达式计算定义，这在动态设置属性或执行属性方法时很好用。

let id = 0;
const user = {
  [`id-${id++}`]: id,
  [`id-${id++}`]: id,
  [`id-${id++}`]: id
};
console.log(user);

使用系统提供的API可以方便获取对象属性与值
const hd = {
  name: "后盾人",
  age: 10
};
console.log(Object.keys(hd)); //["name", "age"]
console.log(Object.values(hd)); //["后盾人", 10]
console.table(Object.entries(hd)); //[["name","后盾人"],["age",10]]

注意Object的keys和values以及entries方法返回的都是数组，而set、map以及其WeakSet和WeakMap都是返回迭代器

对象拷贝
对象赋值时复制的内存地址，所以一个对象的改变直接影响另一个

使用展示语法也可以实现浅拷贝
let obj = {
  name: "后盾人"
};
let hd = { ...obj };

工厂函数：
function stu(name) {
  return {
    name,
    show() {
      console.log(this.name);
    }
  };
}
const lisi = stu("李四");

构造函数：
function Student(name) {
  this.name = name;
  this.show = function() {
    console.log(this.name);
  };
  //不需要返回，系统会自动返回
  // return this;
}
const lisi = new Student("李四");

若构造函数自己返回一个对象，则new实例化后就是这个对象

严格模式
在严格模式下方法中的this值为undefined，这是为了防止无意的修改window对象
"use strict";
function User() {
  this.show = function() {
    console.log(this);
  };
}
let hd = new User();
hd.show(); //User
let xj = hd.show;
xj(); //undefined

内置构造
JS中大部分数据类型都是通过构造函数创建的。
字面量创建的对象，内部也是调用了Object构造函数

在JS中函数也是一个对象

函数是由系统内置的 Function 构造函数创建的
function hd(name) {}
console.log(hd.constructor);
// VM4158:2 ƒ Function() { [native code] }

抽象封装
上例中的方法和属性仍然可以在外部访问到，比如 info方法只是在内部使用，不需要被外部访问到这会破坏程序的内部逻辑。
下面使用闭包特性将对象进行抽象处理
function User(name, age) {
  let data = { name, age };
  let info = function() {
    return data.age > 50 ? "中年人" : "年轻人";
  };
  this.message = function() {
    return `${data.name}是${info()}`;
  };
}
let lisi = new User("后盾人", 22);

查看特征
使用 Object.getOwnPropertyDescriptor查看对象某个属性的描述。
Object.getOwnPropertyDescriptor(user, "name");

使用 Object.getOwnPropertyDescriptors查看对象所有属性的描述
Object.getOwnPropertyDescriptors(user);

使用Object.defineProperty 方法修改属性特性
Object.defineProperty(user, "name", {
  value: "后盾人",
  writable: false,
  enumerable: false,
  configurable: false
});

使用 Object.defineProperties 可以一次设置多个属性，具体参数和上面介绍的一样。
Object.defineProperties(user, {
  name: { value: "向军", writable: false },
  age: { value: 18 }
});

Object.preventExtensions 禁止向对象添加属性
"use strict";
const user = {
  name: "向军"
};
Object.preventExtensions(user);
user.age = 18; //Error

Object.isExtensible 判断是否能向对象中添加属性
"use strict";
const user = {
  name: "向军"
};
Object.preventExtensions(user);
console.log(Object.isExtensible(user)); //false

Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为 configurable: false

Object.isSealed 如果对象是密封的则返回 true，属性都具有 configurable: false。

Object.freeze 冻结对象后不允许添加、删除、修改属性，writable、configurable都标记为false

Object.isFrozen()方法判断一个对象是否被冻结

getter方法用于获得属性值，setter方法用于设置属性，这是JS提供的存取器特性即使用函数来管理属性。

属性访问器
getter方法用于获得属性值，setter方法用于设置属性，这是JS提供的存取器特性即使用函数来管理属性。
const user = {
  data: { name: '后盾人', age: null },
  set age(value) {
    if (typeof value != "number" || value > 100 || value < 10) {
      throw new Error("年龄格式错误");
    }
    this.data.age = value;
  },
  get age() {
    return `年龄是: ${this.data.age}`;
  }
};

使用 defineProperty的enumerable可以模拟定义私有属性，从而使用面向对象的抽象特性。

代理（拦截器）是对象的访问控制，setter/getter 是对单个对象属性的控制，而代理是对整个对象的控制。
读写属性时代码更简洁
对象的多个属性控制统一交给代理完成
严格模式下 set 必须返回布尔值
#使用方法
"use strict";
const hd = { name: "后盾人" };
const proxy = new Proxy(hd, {
  get(obj, property) {
    return obj[property];
  },
  set(obj, property, value) {
    obj[property] = value;
    return true;
  }
});
proxy.age = 10;
console.log(hd);

双向绑定
下面通过代理实现vue 等前端框架的数据绑定特性特性。

json 标准中要求使用双引号包裹属性，虽然有些语言不强制，但使用双引号可避免多程序间传输发生错误语言错误的发生。

基本结构
let hd = {
  "title": "后盾人",
  "url": "houdunren.com",
  "teacher": {
  	"name": "向军大叔",
  }
}
数组结构
let lessons = [
  {
    "title": '媒体查询响应式布局',
    "category": 'css',
    "click": 199
  },
  {
    "title": 'FLEX 弹性盒模型',
    "category": 'css',
    "click": 12
  },
  {
    "title": 'MYSQL多表查询随意操作',
    "category": 'mysql',
    "click": 89
  }
];

序列化是将 json 转换为字符串，一般用来向其他语言传输使用。
let hd = {
  "title": "后盾人",
  "url": "houdunren.com",
  "teacher": {
  	"name": "向军大叔",
  }
}
console.log(JSON.stringify(hd)); 
根据第二个参数指定保存的属性
console.log(JSON.stringify(hd, ['title', 'url']));
//{"title":"后盾人","url":"houdunren.com"}
第三个是参数用来控制TAB数量，如果字符串则为前导字符。
let hd = {
  "title": "后盾人",
  "url": "houdunren.com",
  "teacher": {
  	"name": "向军大叔",
  }
}
console.log(JSON.stringify(hd, null, 4));


为数据添加 toJSON 方法来自定义返回格式
let hd = {
    "title": "后盾人",
    "url": "houdunren.com",
    "teacher": {
        "name": "向军大叔",
    },
    "toJSON": function () {
        return {
            "title": this.url,
            "name": this.teacher.name
        };
    }
}
console.log(JSON.stringify(hd)); //{"title":"houdunren.com","name":"向军大叔"}
toJSON类似toString和valueOf，会被自动调用，当使用JSON.stringify和JSON.parse时，对象的方法toJSON会被调用

反序列化
使用 JSON.parse 将字符串 json 解析成对象

所有函数的原型默认是 Object的实例，所以可以使用toString/toValues/isPrototypeOf 等方法的原因：
Function.prototype.__proto__ === Object.prototype
// true

使用原型对象为多个对象共享属性或方法

如果对象本身不存在属性或方法将到原型上查找

原型包含 constructor 属性，指向构造函数

对象包含 __proto__ 指向他的原型对象

下面使用 setPrototypeOf 与 getPrototypeOf 获取与设置原型
let hd = {};
let parent = { name: "parent" };
Object.setPrototypeOf(hd, parent);
console.log(hd);
console.log(Object.getPrototypeOf(hd));

使用Object.setPrototypeOf 可设置对象的原型，下面的示例中继承关系为 obj>hd>cms。
Object.getPrototypeOf 用于获取一个对象的原型。

使用A isPrototypeOf B检测一个对象A原型是否是另一个对象中

属性遍历
使用in 检测原型链上是否存在属性，使用 hasOwnProperty 只检测当前对象

使用 for/in 遍历时同时会遍历原型上的属性
hasOwnProperty 方法判断对象是否存在属性，而不会查找原型

函数也是对象也有原型，函数有 prototype 属性的__proto__指向他的原型

原型中保存引用类型会造成对象共享属性，所以一般只会在原型中定义方法。

__proto__ 不是对象属性，理解为prototype 的 getter/setter 实现，他是一个非标准定义
__proto__ 内部使用getter/setter 控制值，所以只允许对象或null
建议使用 Object.setPrototypeOf 与Object.getProttoeypOf 替代 __proto__
下面修改对象的 __proto__ 是不会成功的，因为_proto__ 内部使用getter/setter 控制值，所以只允许对象或null
let xj = {};
xj.__proto__ = "向军";
console.log(xj);

下面定义的__proto__ 就会成功，因为这是一个极简对象，没有原型对象所以不会影响__proto__赋值。
let hd = Object.create(null);
hd.__proto__ = "向军";
console.log(hd); //{__proto__: "向军"}

可以使用 __proto__ 或 Object.setPrototypeOf 设置对象的原型，使用Object.getProttoeypOf 获取对象原型。

如果对象中存在属性将使用对象属性，不再原型上查找方法。

以下代码直接设置了构造函数的原型将造成 constructor 丢失

function User(name) {
  this.name = name;
}
User.prototype = {
  show: function() {}
};

正确的做法是要保证原型中的 constructor指向构造函数

function User(name) {
  this.name = name;
}
User.prototype = {
  constructor: User,
  show: function() {}
};

将方法定义在原型上为对象共享，解决通过构造函数创建对象函数复制的内存占用问题

使用Object.assign一次设置原型方法来复用，

当对象中没使用的属性时，JS会从原型上获取这就是继承在JavaScript中的实现。

constructor 会在 new 时自动执行

class A{
  这儿写的都是原型方法
  在constructor的this绑定的方法都是实例化方法
}
A.方法是静态方法

构造函数用于传递对象的初始参数，但不是必须定义的

class User {
  site = "后盾人"; //这儿和在constructor中this.site设置是一样的
  constructor(name) {
    this.name = name;
  }
  show() { // 默认方法是作为原型上的方法
    console.log(this.site + ":" + this.name);
  }
}

class语法糖中中定义的方法不能枚举，而构造函数中可以

静态属性即为类设置属性，而不是为生成的对象设置
function User() {}
User.site = "后盾人";

在 class 中为属性添加 static 关键字即声明为静态属性

静态方法
指通过类访问不能使用对象访问的方法
User.show = function() {
  return "welcome to houdunren";
};

在 class 内声明的方法前使用 static 定义的方法即是静态方法

class将属性定义为以 _ 开始，来告诉使用者这是一个私有属性，请不要在外部使用。继承时是可以使用的

Symbol
下面使用 Symbol定义私有访问属性，即在外部通过查看对象结构无法获取的属性
const protecteds = Symbol();
class Common {
  constructor() {
    this[protecteds] = {};
    this[protecteds].host = "https://houdunren.com";
  }
  set host(url) {
    if (!/^https?:/i.test(url)) {
      throw new Error("非常网址");
    }
    this[protecteds].host = url;
  }
  get host() {
    return this[protecteds].host;
  }
}

private
private 指私有属性，只在当前类可以访问到，并且不允许继承使用
为属性或方法名前加 # 为声明为私有属性
私有属性只能在声明的类中使用
注意，私有属性依然能被看到，只是不能使用
class Cat{
  constructor(){}
  #name = "小猫";
  like(){
    return `${this.#name}喜欢吃鱼`;
  }
}

继承时必须在子类构造函数中调用 super() 执行父类构造函数
super.show() 执行父类方法

虽然JS没有命名空间的概念，使用模块可以解决全局变量冲突
模块需要隐藏内部实现，只对外开发接口
模块可以避免滥用全局变量，造成代码不可控
模块可以被不同的应用使用，提高编码效率

在过去JS不支持模块时我们使用AMD/CMD（浏览器端使用）、CommonJS（Node.js使用）、UMD(两者都支持)等形式定义模块。

AMD代表性的是 require.js，CMD 代表是淘宝的 seaJS 框架。

在浏览器中使用以下语法靠之脚本做为模块使用，这样就可以在里面使用模块的代码了。
在html文件中导入模块，需要定义属性 type="module"
<script type="module">
  import { hd } from "hd.js";
</script>

模块总是会在所有html解析后才执行

模块默认运行在严格模式

模块都有独立的顶级作用域，下面的模块不能互相访问

模块在导入时只执行一次解析，之后的导入不会再执行模块代码，而使用第一次解析结果，并共享数据。

使用export 将开发的接口导出
使用import 导入模块接口
使用*可以导入全部模块接口
导出是以引用方式导出，无论是标量还是对象，即模块内部变量发生变化将影响已经导入的变量
使用 export 导出模块接口，没有导出的变量都是模块私有的。

export const site = "后盾人";

const site = "后盾人";
export { site};

import {site} from "./hd.js";

模块默认是在顶层静态导入

import * as api from "./hd.js";
console.log(api.site);
console.log(api.User);

模块导入使用 as 对接口重命名，本模块中已经存在 func 变量，需要对导入的模块重命名防止重名错误。
import { User as user, func as action, site as name } from "./hd.js";


模块可以对导出给外部的功能起别名，下面是hd.js 模块对导出给外部的模块功能起了别名
export { site, func as action, User as user };

很多时候模块只是一个类，也就是说只需要导入一个内容，这地可以使用默认导入。
使用default 定义默认导出的接口，导入时不需要使用 {}

可以为默认导出自定义别名

只能有一个默认导出

默认导出可以没有命名

export default class {
  static show() {
    console.log("User.method");
  }
}

从程序来讲如果将一个导出命名为 default 也算默认导出
class User {
  static show() {
    console.log("User.method");
  }
}
export { User as default };

模块可以存在默认导出与命名导出。

使用export default 导出默认接口，使用 export {} 导入普通接口
const site = "后盾人";
const func = function() {
  console.log("is a module function");
};
export default class {
  static show() {
    console.log("user.show");
  }
}
export { site, func };

export { site, func };

也可以使用以下方式导出模块
const site = "后盾人";
const func = function() {
  console.log("is a module function");
};
class User {
  static show() {
    console.log("user.show");
  }
}
export { site, func, User as default };

导入默认接口时不需要使用 {} ，普通接口还用 {} 导入
import hd from "./hd.js";
import { site } from "./hd.js";

也可以使用别名导入默认导出
import { site, default as hd } from "./hd.js";

import * as api from "./hd.js";
console.log(api.site);
api.default.show();

不建议使用默认导出，会让开发者导入时随意命名

如果使用默认导入最好以模块的文件名有关联，会使用代码更易阅读

导出合并
#解决问题
可以将导入的模块重新导出使用，比如项目模块比较多如下所示，这时可以将所有模块合并到一个入口文件中。
这样只需要使用一个模块入口文件，而不用关注多个模块文件

使用 * 会将默认模块以 default 导出,因为用*，默认模块没有名字，则以default访问

使用 import 必须在顶层静态导入模块，而使用import() 函数可以动态导入模块，它返回一个 promise 对象。
<script>
  if (true) {
    let hd = import("./hd.js").then(module => {
      console.log(module.site);
    });
  }
</script>

export function show(){}	导出函数
export const name='后盾人'	导出变量
export class User{}	导出类
export default show	默认导出
const name = '后盾人'
export {name}	导出已经存在变量
export {name as hd_name}	别名导出
import defaultVar from 'houdunren.js'	导入默认导出
import {name,show} from 'a.j'	导入命名导出
Import {name as hdName,show} from 'houdunren.js'	别名导入
Import * as api from 'houdunren.js'	导入全部接口

正则表达式是用于匹配字符串中字符组合的模式，在 JavaScript中，正则表达式也是对象。

let hd = "houdunren2200hdcms9988";
console.log(hd.match(/\d/g).join(""));

提供字面量与对象两种方式创建正则表达式

使用//包裹的字面量创建方式是推荐的作法，但它不能在其中使用变量

let hd = "houdunren.com";
let a = "u";
console.log(/a/.test(hd)); //false
console.log((new RegExp(`${a}`)).test(hd)) //true

| 这个符号带表选择修释符，也就是 | 左右两侧有一个匹配到就可以。
const hd = "houdunren";
console.log(/houdunren|hdcms/.test(hd)); //true

a+ 表示匹配一个以上a
a? 表示匹配一个或0个a
a* 表示有一个以上a或0个
.表示任意字符

^	匹配字符串的开始
$	匹配字符串的结束，忽略换行符
const hd = "www.houdunren.com";
console.log(/\.com$/.test(hd)); //true
const hd = "www.houdunren.com";
console.log(/^www/.test(hd)); //true

\d	匹配任意一个数字	[0-9]
\D	与除了数字以外的任何一个字符匹配	[^0-9]
\w	与任意一个英文字母,数字或下划线匹配	[a-zA-Z0-9_]
\W  除了字母,数字或下划线外与任何字符匹配	[^a-zA-Z_]
\s	任意一个空白字符匹配，如空格，制表符\t，换行符\n	[\n\f\r\t\v]
\S	除了空白符外任意一个字符匹配	[^\n\f\r\t\v]
.	匹配除换行符外的任意字符	

使用/s视为单行模式（忽略换行）时，. 可以匹配所有
let hd = `
  <span>
    houdunren
    hdcms
  </span>
`;
let res = hd.match(/<span>.*<\/span>/s);
console.log(res[0]);

正则中空格会按普通字符对待
let tel = `010 - 999999`;
console.log(/\d+-\d+/.test(tel)); //false
console.log(/\d+ - \d+/.test(tel)); //true

可以使用 [\s\S] 或 [\d\D] 来匹配所有字符

i	不区分大小写字母的匹配
g	全局搜索所有匹配内容
m	视为多行，m修饰符规定正则表达式可以执行多行匹配,在默认状态下，一个字符串无论是否换行只有一个开始^和结尾$，如果采用多行匹配，那么每一个行都有一个^和结尾$
s	视为单行忽略换行符，使用. 可以匹配所有字符
y	从 regexp.lastIndex 开始匹配


str = `a
b
c
d
e`;
/^[a-zA-Z]$/.test(str);
false
/^[a-zA-Z]$/m.test(str);
true

var regexp = /abcd/g;
var str = 'abcdefg';
alert(regexp.test(str));  //true
alert(regexp.test(str));  //false
alert(regexp.test(str));  //true
上面这段代码运行的结果分别是弹出true、false、true,考虑到用的是同一个正则模式，是不是让人有点迷糊？
其实这正是正则表达式对象的lastIndex属性在作怪。lastIndex从字面上来讲就是最后一个索引，实际上它的意思是正则表达式开始下一次查找的索引位置，第一次的时候总是为0的，第一次查找完了的时候会把lastIndex的值设为匹配到得字符串的最后一个字符的索引位置加1，第二次查找的时候会从lastIndex这个位置开始，后面的以此类推。如果没有找到，则会把lastIndex重置为0。要注意的是，lastIndex属性只有在有全局标志正则表达式中才有作用，如果我们把上面代码中正则表达式的g标志去掉，那么三次弹出的就都是true了。

[]	只匹配其中的一个原子
[^]	只匹配"除了"其中字符的任意一个原子
[0-9]	匹配0-9任何一个数字
[a-z]	匹配小写a-z任何一个字母
[A-Z]	匹配大写A-Z任何一个字母

原子表中有些正则字符不需要转义，如果转义也是没问题的，可以理解为在原子表中. 就是小数点
/[.+*]/.test("*") /true/

exec或match匹配结果
index 匹配的开始位置
input 原始数据
groups 组别名

/^(a)\1$/.test("aa") //true
(a)代表一个原子组，\1表示引用第一个原子组，/^(a)\1$/等价于/^(a)a$/

\n 在匹配时引用原子组， $n 指在替换时使用匹配的组数据
let reg = /<(h[1-6])>([\s\S]*)<\/\1>/gi;
console.log(hd.replace(reg, `<p>$2</p>`));

如果只希望原子组起到改变优先级作用，不希望使用\n和$n以及显示()匹配到的结果,使用 (?: 处理

如果希望返回的组数据更清晰，可以为原子组编号，结果将保存在返回的 groups字段中
组别名使用 ?<别名> 形式定义，这样定义之后，()匹配到的内容会作为groups的属性值，而别名作为groups的属性名
let hd = "<h1>houdunren.com</h1>";
console.dir(hd.match(/<(?<tag>h[1-6])[\s\S]*<\/\1>/));

*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次

/a+/.exec("aaaa") => "aaaa" 贪婪模式
/a+?/.exec("aaaa") => "a" 非贪婪模式

let str = "aaa";
console.log(str.match(/a+/)); //aaa
console.log(str.match(/a+?/)); //a
console.log(str.match(/a{2,3}?/)); //aa
console.log(str.match(/a{2,}?/)); //aa

在新浏览器中支持使用 matchAll 操作，并返回迭代对象
let str = "houdunren";
let reg = /[a-z]/ig;
for (const iterator of str.matchAll(reg)) {
  console.log(iterator);
}

字符方法
search() 方法用于检索字符串中指定的子字符串，也可以使用正则表达式搜索，返回值为索引位置

match
如果使用 g 修饰符时，就不会有结果的详细信息了（可以使用exec）

let str = "2023/02-12";
console.log(str.split(/-|\//));

replace 方法不仅可以执行基本字符替换，也可以进行正则替换

$$	插入一个 "$"。
$&	插入匹配的子串。
$`	插入当前匹配的子串左边的内容。
$'	插入当前匹配的子串右边的内容。
$n	假如第一个参数是 RegExp 对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始

在后盾人前后添加三个=
let hd = "=后盾人=";
console.log(hd.replace(/后盾人/g, "$`$`$&$'$'"));


match	匹配的子串。（对应于上述的$&。）
p1,p2, ...	假如replace()方法的第一个参数是一个 RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如，如果是用 /(\a+)(\b+)/ 这个来匹配，p1 就是匹配的 \a+，p2 就是匹配的 \b+。
offset	匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是 'abcd'，匹配到的子字符串是 'bc'，那么这个参数将会是 1）
string	被匹配的原字符串。
NamedCaptureGroup	命名捕获组匹配的对象

function replacer(match, p1, p2, p3, offset, string) {
  // p1 is nondigits, p2 digits, and p3 non-alphanumerics
  return [p1, p2, p3].join(' - ');
}
var newString = 'abc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
console.log(newString);  // abc - 12345 - #$*%


let i = 3;
let reg = /a/g;
while((i--)>0){
  console.log(reg.exec("aa"),reg.lastIndex);
}

exec
不使用 g 修饰符时与 match 方法使用相似，使用 g 修饰符后可以循环调用直到全部匹配完。
使用 g 修饰符多次操作时使用同一个正则，即把正则定义为变量使用
使用 g 修饰符最后匹配不到时返回 null

(?=exp)
零宽先行断言 ?=exp 匹配后面为 exp 的内容

(?<=exp)
零宽后行断言 ?<=exp 匹配前面为 exp 的内容

(?!exp)
零宽负向先行断言 后面不能出现 exp 指定的内容

(?<!exp)
零宽负向后行断言 前面不能出现exp指定的内容


JavaScript 中存在很多异步操作,Promise 将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。可以通过链式调用多个 Promise 达到我们的目的。

Promise用来解决回调地狱问题

使用传统的异步请求也会产生回调嵌套的问题
function ajax(url, resolve, reject) {
  let xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.send();
  xhr.onload = function() {
    if (this.status == 200) {
      resolve(JSON.parse(this.response));
    } else {
      reject(this);
    }
  };
}
ajax("http://localhost:8888/php/user.php?name=向军", user => {
  ajax(
    `http://localhost:8888/php/houdunren.php?id=${user["id"]}`,
    response => {
      console.log(response[0]);
    }
  );
});

一个 promise 必须有一个 then 方法用于处理状态改变

Promise包含pending、fulfilled、rejected三种状态

pending 指初始等待状态，初始化 promise 时的状态
resolve 指已经解决，将 promise 状态设置为fulfilled
reject 指拒绝处理，将 promise 状态设置为rejected

状态一旦改变将不可更改

promise 是队列状态，就像体育中的接力赛，或多米诺骨牌游戏，状态一直向后传递，当然其中的任何一个promise也可以改变状态。


promise 没有使用 resolve 或 reject 更改状态时，状态为 pending

在调用then之后，默认是成功状态也就是resolved，return 任何数据类型，默认是return Promise.resolve(你return的数据)

promise 创建时即立即执行即同步任务，then 会放在异步微任务中执行，需要等同步任务执行后才执行。
let promise = new Promise((resolve, reject) => {
  resolve("fulfilled");
  console.log("后盾人");
});
promise.then(msg => {
  console.log(msg);
});
console.log("houdunren.com");

promise 的 then、catch、finally的方法都是异步任务
程序需要将主任务执行完成才会执行异步队列任务

catch可以捕获Promise链上任何错误

状态被改变后就不能再修改了
new Promise((resolve, reject) => {
  resolve("操作成功");
  reject(new Error("请求失败"));
}).then(
  msg => {
    console.log(msg);
  },
  error => {
    console.log(error);
  }
);

如果 resolve 参数是一个 promise ，将会改变promise状态。

reject就是一个报错，可以被catch捕获，或then第二个参数捕获

如果resolve代码之前出现报错或reject，则resolve不起作用
new Promise(resolve=>{throw("Error");resolve(1)})
.then(()=>console.log("success"),err=>console.log(err));
这是因为报错会把Promise状态改编成rejected

因为p2 的resolve 返回了 p1 的promise，所以此时p2 的then 方法已经是p1 的了
正因为以上原因 then 的第一个函数输出了 p1 的 resolve 的参数
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("操作成功");
  }, 2000);
});
const p2 = new Promise((resolve, reject) => {
  resolve(p1);
}).then(
  msg => {
    console.log(msg);
  },
  error => {
    console.log(error);
  }
);

then 方法必须返回 promise，用户返回或系统自动返回

如果 then 返回 promise ，下一个then 会在当前promise 状态改变后执行

then 第一个函数在 resolve成功状态执行,第二个参数在失败状态执行

如果只关心失败时状态，then 的第一个参数传递 null

promise 传向then的传递值，如果then没有可处理函数，会一直向后传递

let p1 = new Promise((resolve, reject) => {
	reject("rejected");
})
.then()
.then(
  null,
  f => console.log(f)
);

每次的 then 都是一个全新的 promise，默认 then 返回的 promise 状态是 fulfilled

每次的 then 都是一个全新的 promise，不要认为上一个 promise状态会影响以后then返回的状态

如果内部返回 promise 时将使用该 promise

循环调用
如果 then 返回与 promise 相同将禁止执行

如果返加值是 promise 对象，则需要更新状态后，才可以继承执行后面的then
new Promise((resolve, reject) => {
  resolve(
    new Promise((resolve, reject) => {
      setTimeout(() => {
        reject("解决状态");
      }, 2000);
    })
  );
})
.then(null,it=>console.log(it));

包含 then 方法的对象就是一个 promise ，系统将传递 resolvePromise 与 rejectPromise 做为函数参数
下例中使用 resolve 或在then 方法中返回了具有 then方法的对象
该对象即为 promise 要先执行，并在方法内部更改状态
如果不更改状态，后面的 then promise都为等待状态
new Promise((resolve, reject) => {
  resolve({
    then(resolve, reject) {
      resolve("解决状态");
    }
  });
})
.then(v => {
  console.log(`fulfilled: ${v}`);
  return {
    then(resolve, reject) {
      setTimeout(() => {
        reject("失败状态");
      }, 2000);
    }
  };
})
.then(null, error => {
  console.log(`rejected: ${error}`);
});

包含 then 方法的对象可以当作 promise来使用
class User {
  constructor(id) {
    this.id = id;
  }
  then(resolve, reject) {
    resolve(ajax(`http://localhost:8888/php/houdunren.php?id=${this.id}`));
  }
}
new Promise((resolve, reject) => {
  resolve(ajax(`http://localhost:8888/php/user.php?name=向军`));
})
.then(user => {
  return new User(user.id);
})
.then(lessons => {
  console.log(lessons);
});

当然也可以是类
new Promise((resolve, reject) => {
  resolve(
    class {
      static then(resolve, reject) {
        setTimeout(() => {
          resolve("解决状态");
        }, 2000);
      }
    }
  );
}).then(
  v => {
    console.log(`fulfilled: ${v}`);
  },
  v => {
    console.log(`rejected: ${v}`);
  }
);

如果对象中的 then 不是函数，则将对象做为值传递，也就是必须是then方法对象返回时才能作为Promise使用
new Promise((resolve, reject) => {
  resolve();
})
.then(() => {
  return {
    then: "后盾人"
  };
})
.then(v => {
  console.log(v); //{then: "后盾人"}
});

下面使用未定义的变量同样会触发失败状态
let promise = new Promise((resolve, reject) => {
  hd;
}).then(
  value => console.log(value),
  reason => console.log(reason)
);

如果 onFulfilled 或 onRejected 抛出异常，则 p2 拒绝执行并返回拒因
let promise = new Promise((resolve, reject) => {
  throw new Error("fail");
});
let p2 = promise.then();
p2.then().then(null, resolve => {
  console.log(resolve + ",后盾人");
});

catch用于失败状态的处理函数，等同于 then(null,reject){}

catch 可以捕获之前所有 promise 的错误，所以建议将 catch 放在最后。下例中 catch 也可以捕获到了第一个 then 返回 的 promise 的错误。
new Promise((resolve, reject) => {
  resolve();
})
.then(() => {
  return new Promise((resolve, reject) => {
    reject(".then ");
  });
})
.then(() => {})
.catch(msg => {
  console.log(msg);
});

错误和成功都是冒泡的操作的
new Promise((resolve, reject) => {
  reject(new Error("请求失败"));
})
.then(msg => {})
.then(msg => {})
.catch(error => {
  console.log(error);
});

报错会改变Promise的状态为rejected
new Promise((resolve, reject) => {
  resolve();
})
.then(msg => {
  throw new Error("这是then 抛出的错误");
})
.then(null,it=>console.log(it));

catch 也可以捕获其他错误，下面在 then 中使用了未定义的变量，将会把错误抛出到 catch

建议将错误要交给catch处理而不是在then中完成

在 promise 中抛出的错误也会被catch 捕获

reject也会被catch捕获
Promise.reject(1).catch(it=>console.log(it))

try catch不能捕获Promise.reject()：
try{new Promise((a,b)=>b(1))}catch(e){console.log(e)}


const promise = new Promise((resolve, reject) => {
    throw new Error("fail");
}).catch(msg => {
  console.log(msg + "后盾人");
});

Promise的错误不会被try catch捕获，因此必须使用Promise.catch捕获

在 catch 中发生的错误也会抛给最近的错误处理
const promise = new Promise((resolve, reject) => {
  reject();
})
.catch(msg => {
  hd();
})
.then(null, error => {
  console.log(error);
});

定制错误
class ParamError extends Error {
  constructor(msg) {
    super(msg);
    this.name = "ParamError";
  }
}
throw new ParamError("请求地址格式错误");

无论状态是resolve 或 reject 都会执行此动作，finally 与状态无关。

如果 then 返回 promse，只当promise 结束后，才会继承执行下一个 then

promise 中的 then 方法可以链接执行，then 方法的返回值会传递到下一个then 方法。

then 会返回一个promise ，所以如果有多个then 时会连续执行
then 返回的值会做为当前promise 的结果
Promise.resolve(1).then(it=>console.log(it)).then(it=>console.log(2))
因为then方法不手动返回的化，默认返回Promise.resolve();

使用 promise.resolve 方法可以快速的返回一个promise对象
Promise.resolve("后盾人").then(value => {
  console.log(value); //后盾人
});

reject
和 Promise.resolve 类似，reject 生成一个失败的promise
Promise.reject("fail").catch(error => console.log(error));




使用Promise.all 方法可以同时执行多个并行异步操作，比如页面加载时同进获取课程列表与推荐课程。
任何一个 Promise 执行失败就会调用 catch方法
两个 Promise 状态都为 fulfilled 时，Promise.all状态才为fulfilled

allSettled 用于处理多个promise ，只关注执行完成，不关注是否全部执行成功，allSettled 状态只会是fulfilled。
当所有Promise状态不为pendding时，allSettled状态改为fulfilled
const p1 = new Promise((resolve, reject) => {
  resolve("resolved");
});
const p2 = new Promise((resolve, reject) => {
  reject("rejected");
});
Promise.allSettled([p1, p2])
.then(msg => {
  console.log(msg);
})

使用Promise.race() 处理容错异步，和race单词一样哪个Promise快用哪个，哪个先返回用哪个。
以最快返回的promise为准，不管状态，哪个状态先不为pendding，则使用

使用 async/await 是promise 的语法糖，可以让编写 promise 更清晰易懂，也是推荐编写promise 的方式。

async/await 本质还是promise，只是更简洁的语法糖书写
async/await 使用更清晰的promise来替换 promise.then/catch 的方式

一般await后面是外部其它的promise对象

若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。
若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出

如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。

和 promise 一样，await 也可以操作thenables 对象
class User {
  constructor(name) {
    this.name = name;
  }
  then(resolve, reject) {
    let user = ajax(`http://localhost:8888/php/user.php?name=${this.name}`);
    resolve(user);
  }
}
async function get() {
  let user = await new User("向军");
  console.log(user);
}
get();

async function get(name) {
  return await ajax(`http://localhost:8888/php/user.php?name=${name}`);
}
get("后盾人").then(user => {
  console.log(user);
});
这里的return会返回Promise.resolve(return值)

async 内部发生的错误，会将必变promise对象为rejected 状态，所以可以使用catch 来处理
async function hd() {
  console.log(houdunren);
}
hd().catch(error => {
  throw new Error(error);
});

若async函数不手动返回，则返回Promise.resolve()

如果promise 被拒绝将抛出异常，可以使用 try...catch 处理错误

async function get(name) {
  try {
    let user = await ajax(
      `http://localhost:8888/php/user.php?name=${name}`
    );
    console.log(user);
  } catch (error) {
    alert("用户不存在");
  }
}
get("向军老师");

多个 await 时当前面的出现失败，后面的将不可以执行

如果对前一个错误进行了处理，后面的 await 可以继续执行

也可以使用 try...catch 特性忽略不必要的错误

也可以将多个 await 放在 try...catch 中统一处理错误

使用 Promise.all() 处理多个promise并行执行
async function hd() {
  await Promise.all([p1(), p2()]);
}
hd();

让promise先执行后再使用await处理结果
async function hd() {
  let h1 = p1();
  let h2 = p2();
  await h1;
  await h2;
}
hd();

JavaScript 语言的一大特点就是单线程，也就是说同一个时间只能处理一个任务。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的不阻塞，（事件循环）Event Loop的方案应用而生。

JavaScript 处理任务是在等待任务、执行任务 、休眠等待新任务中不断循环中，也称这种机制为事件循环。

主线程中的任务执行完后，才执行任务队列中的任务
有新任务到来时会将其放入队列，采取先进先执行的策略执行队列中的任务
比如多个 setTimeout 同时到时间了，就要依次执行

任务包括 script(整体代码)、 setTimeout、setInterval、DOM渲染、DOM事件、Promise、XMLHTTPREQUEST等

主线程、宏任务队列、微任务队列
微任务队列执行完之后才执行下一个宏任务，因为微任务优先级高

引擎在执行任务时不会进行DOM渲染，所以如果把script 定义在前面，要先执行完任务后再渲染DOM，建议将script 放在 BODY 结束标签前。

下面的代码会先输出 houdunren.com 之后输出 后盾人

setTimeout(() => {
  console.log("后盾人");
}, 0); //到这儿之后，把回调函数放入宏任务队列等待执行，向下继续执行当前宏任务script
console.log("houdunren.com");

setTimeout(() => {
  console.log("定时器");
  setTimeout(() => {
    console.log("timeout timeout");
  }, 0);
  new Promise(resolve => {
    console.log("settimeout Promise");
    resolve();
  }).then(() => {
    console.log("settimeout then");
  });
}, 0);
new Promise(resolve => {
  console.log("Promise");
  resolve();
}).then(() => {
  console.log("then");
});
console.log("后盾人");
执行结果：
Promise
后盾人
then
定时器
settimeout Promise
settimeout then
timeout timeout

下面的定时器虽然都定时了一秒钟，但也是按先进行出原则，依次执行
let i = 0;
setTimeout(() => {
  console.log(++i);
}, 1000);
setTimeout(() => {
  console.log(++i);
}, 1000);

操作文档HTML的JS处理方式为DOM 即Document Object Model 文档对象模型

浏览器页面渲染原理：
https://www.cnblogs.com/caizhenbo/p/6679478.html
https://zhuanlan.zhihu.com/p/29418126

回流和重绘：https://www.jianshu.com/p/e081f9aa03fb

在html中只有内容houdunren.com 而没有任何标签时，浏览器会自动修复成以下格式
<html>
<head></head>
<body>
houdunren.com
</body>
</html>

下面H1标签结束错误并且属性也没有引号，浏览器在渲染中会进行修复
<body>
  <h1 id=houdunren>后盾人<h1>
</body>

表格tabel中不允许有内容，浏览器在渲染过程中会进行处理
<table>
  houdunren.com
  <tr>
    <td>hdcms.com</td>
  </tr>
</table>

渲染后会添加tbody标签并将table中的字符移出
houdunren.com
<table>
  <tbody>
  	<tr>
      <td>hdcms.com</td>
    </tr>
  </tbody>
</table>

标签移动
所有内容要写在BODY标签中，下面的SCRIPT标签写在了BODY后面，浏览器渲染后也会进行处理
<body></body>
<script>
  console.dir('houdunren.com')
</script>
渲染后处理的结果
<body>
  <script>
    console.dir('houdunren.com')
  </script>
</body>

需要保证浏览器已经渲染了内容才可以读取的节点对象，下例将无法读取到节点对象
<script>
  const node = document.getElementById('hdcms')
  console.log(node) //null
</script>
<h1 id="hdcms">houdunren.com</h1>
js操作DOM树，而script在h1前面，DOM中还没有绘制h1节点

DOMContentLoaded会在渲染树把内容渲染到页面上之后，立即执行，不等待图片等资源加载
load会在图片等资源也加载完之后执行

Jquery的ready方法就是由DOMContentLoaded触发
Jquery的onload方法触发load

不过我们可以将脚本通过事件放在页面渲染完执行
<script>
  window.onload = () => {
    const node = document.getElementById('hdcms')
    console.log(node)
  }
</script>
<h1 id="hdcms">houdunren.com</h1>
或使用定时器将脚本设置为异步执行

或将脚本设置在外部文件并使用defer属性加载，defer即会等到DOM解析后迟延执行

defer和async区别：https://blog.csdn.net/function__/article/details/79321540

节点由nodeType、nodeName、nodeValue。
nodeType == 1  ： 元素节点
nodeType == 2  ： 属性节点
nodeType == 3  ： 文本节点
注释 comments   8
文档 document   9
documentFragment 11

可以获取文本节点document.querySelector("div").firstchild

使用对象特性更改样式属性
<div id="hd">houdunren.com</div>
<script>
  let hd = document.getElementById('hd')
  Object.assign(hd.style, {
    color: 'white',
    backgroundColor: 'red',
  })
</script>

系统提供了简单的方式来获取html元素
console.log(document.documentElement)

document.body获取body标签

//获取文档标题
console.log(document.title)
或document[title]

获取当前URL
console.log(document.URL)

获取域名
document.domain

获取上一个页面的URL，若是刚打开的页面则为""
document.referrer

nodeType	说明
1	元素节点
2	属性节点
3	文本节点
8	注释节点
9	document对象

children只返回元素节点
childNodes返回元素节点、文本节点

nodeType	nodeName
1	元素名称如DIV
2	属性名称
3	#text
8	#comment
9 #document

nodeName可以获取不限于元素的节点名，tagName仅能用于获取元素节点名称
document.body.tagName => "BODY"

使用data属性获取节点内容
 const app = document.querySelector('#app')
  console.log(app.childNodes[0].data)

Nodelist与HTMLCollection都是包含多个节点标签的集合，大部分功能也是相同的。

有时使用数组方法来操作节点集合，这就需要将节点集合转化为数组类型

item
Nodelist与HTMLCollection提供了item()方法来根据索引获取元素
const nodes = document.getElementsByTagName('div')
console.dir(nodes.item(0))
使用数组索引获取更方便
console.dir(nodes[0])

namedItem
HTMLCollection具有namedItem方法可以按name或id属性来获取元素
<div name="app">
  <div id="houdunren">houdunren.com</div>
  <div name="hdcms">hdcms.com</div>
</div>
<script>
  const nodes = document.getElementsByTagName('div')
  console.dir(nodes.namedItem('hdcms'))
   console.dir(nodes.namedItem('houdunren'))
</script>

HTMLCollection具有namedItem方法可以按name或id属性来获取元素，只找到第一个

document.documentElement	文档节点即html标签节点
document.body	body标签节点
document.head	head标签节点
document.links	超链接集合
document.forms	form表单集合
document.images	图片集合

节点是父子级嵌套与前后兄弟关系，使用DOM提供的API可以获取这种关系的元素。
文本和注释也是节点，所以也在匹配结果中

childNodes	获取所有子节点 对比 children
parentNode	获取父节点 对比 parentElement
firstChild	子节点中第一个 对比 firstElementChild
lastChild	子节点中最后一个 对比 lastElementChild
nextSibling	下一个兄弟节点 对比 nextElementSibling
previousSibling	上一个兄弟节点 对比 previousElementSibling


<script>
  console.log(document.documentElement.parentNode === document) //这是true
  console.log(document.documentElement.parentElement === document) //这是false，为null
</script>

parentElement	获取父元素
children	获取所有子元素
childElementCount	子标签元素的数量
firstElementChild	第一个子标签
lastElementChild	最后一个子标签
previousElementSibling	上一个兄弟标签
nextElementSibling	下一个兄弟标签

document.body.children.length === document.body.childElementCount

getElementById
getElementsByName
getElementsByTagName
getElementsByClassName
可以使用通配符 * 获取所有元素，如getElementsByTagName("*")

forEach
Nodelist节点列表也可以使用forEach来进行遍历，但HTMLCollection则不可以

map
节点集合对象原型中不存在map方法，但可以借用Array的原型map方法实现遍历
const nodes = document.querySelectorAll('div')
  Array.prototype.map.call(nodes, (node, index) => {
  console.log(node, index)
})

节点集合是类数组的可迭代对象所以可以使用for...of进行遍历

样式选择器
querySelectorAll
querySelector


matches
用于检测元素是否是指定的样式选择器匹配，下面过滤掉所有name属性的LI元素
nodes = document.querySelectorAll("div");
nodes[0].matches(`[name]`) // 返回true

closest
查找最近的符合选择器的祖先元素（包括自身），下例查找父级拥有 .comment类的元素
const li = document.getElementsByTagName('li')[0]
const node = li.closest(`.comment`)
console.log(node)

通过 getElementsByTagname 等getElementsBy... 函数获取的Nodelist与HTMLCollection集合是动态的，即有元素添加或移动操作将实时反映最新状态。

使用getElement...返回的都是动态的集合
使用querySelectorAll返回的是静态集合

有些属性名与JS关键词冲突，系统已经起了别名
属性	别名
class	className
for	htmlFor

返回 label 的 for 属性的值：
document.querySelector("label").htmlFor;

addEventListener里的回调函数的this指向节点

getAttribute	获取属性
setAttribute	设置属性
removeAttribute	删除属性
hasAttribute	属性检测

attributes
元素提供了attributes 属性可以只读的获取元素的属性

虽然可以随意定义特征并使用getAttribute等方法管理，但很容易造成与标签的现在或未来属性重名。建议使用以data-为前缀的自定义特征处理，针对这种定义方式JS也提供了接口方便操作。

元素中以data-为前缀的属性会添加到属性集中
使用元素的dataset可获取属性集中的属性
改变dataset的值也会影响到元素上
多个单词的特征使用驼峰命名方式读取

data-a-b-c 在dom中只可以这样写dataset.aBC

特征和属性是记录元素属性的两个不同场所，大部分更改会进行同步操作。
下面对input值使用属性设置，但并没有同步到特征
<input type="text" name="package" value="houdunren.com" />
<script>
  const package = document.querySelector(`[name='package']`)
  package.value = 'hdcms.com'
  console.log(package.getAttribute('value'))//houdunren.com
</script>

但改变input的特征value会同步到DOM对象属性
<input type="text" name="package" value="houdunren.com" />
<script>
  const package = document.querySelector(`[name='package']`)
  package.setAttribute('value', 'hdcms.com')
  console.log(package.value) //hdcms.com
</script>

createTextNode
createElement
createDocumentFragment


append和appendChild区别：https://www.cnblogs.com/ivan5277/p/10119144.html


createDocumentFragment的好处：https://blog.csdn.net/qiao13633426513/article/details/80243058

创建的节点的parentNode为null
使用createDocumentFragment创建的节点来暂存文档节点
createDocumentFragment创建的节点添加到其他节点上时，会将子节点一并添加
createDocumentFragment是虚拟节点对象，不直接操作DOM所以性能更好
在排序/移动等大量DOM操作时建议使用createDocumentFragment

cloneNode&importNode
使用cloneNode和document.importNode用于复制节点对象操作
cloneNode是节点方法
cloneNode 参数为true时递归复制子节点即深拷贝
importNode是documet对象方法

document.importNode方法是部分IE浏览器不支持的，也是复制节点对象的方法
第一个参数为节点对象
第二个参数为true时递归复制

注意：克隆只能克隆标签原本有的内容，比如属性或标签上绑定的事件等等，但是script中人为添加的事件，克隆不到

innerHTML
inneHTML用于向标签中添加html内容，同时触发浏览器的解析器重绘DOM。

重绘节点
使用innertHTML操作会重绘元素，下面在点击第二次就没有效果了
因为对#app内容进行了重绘，即删除原内容然后设置新内容
重绘后产生的button对象没有事件
重绘后又产生了新img对象，所以在控制台中可看到新图片在加载

outerHTML和innerHTML会导致重绘，手动绑定的事件全部被删除，https://bbs.csdn.net/topics/392153802

textContent与innerText
textContent与innerText是访问或添加文本内容到元素中
textContent部分IE浏览器版本不支持
innerText部分FireFOx浏览器版本不支持
获取时忽略所有标签
设置时将内容中的标签当文本对待不进行解析

insertAdjacentText和insertAjacentHTML
将文本插入到元素指定位置，insertAdjacentText不会对文本中的标签进行解析，而insertAjacentHTML会，包括以下位置
选项	说明
beforebegin	元素本身前面
afterbegin	元素内部前面
beforeend	元素内部后面
afterend	元素本身后面

append	节点尾部添加新节点或字符串
prepend	节点开始添加新节点或字符串
before	节点前面添加新节点或字符串
after	节点后面添加新节点或字符串
replaceWith	将节点替换为新节点或字符串

node.remove()用来删除节点本身，不反悔
Node.removeChild() 方法从DOM中删除一个子节点。返回删除的节点。

下面列表过去使用的操作节点的方法，现在不建议使用了。但在阅读老代码时可来此查看语法
方法	说明
appendChild	添加节点
insertBefore	用于插入元素到另一个元素的前面
removeChild	删除节点
replaceChild	进行节点的替换操作

使用document.forms获取表单集合
例如:
<form action="" name="name-form" id="id-form">
    <input type="text" id="id-input" name="name-input">
</form>
获取form可以：id和name都可以
1. document.forms["id-form"]（或["name-form"]）
2. document.forms["name-form"]（或["id-form"]）["id-input"]（或["id-input"]）.form

获取input：id和name都可以
1. document.forms["name-form"]["name-input"]
2. document.forms["name-form"]["id-input"]

通过DOM修改样式可以通过更改元素的class属性或通过style对象设置行样式来完成。
建议使用class控制样式，将任务交给CSS处理，更简单高效

使用JS的className可以批量设置样式
app.className = 'hdcms'
也可以通过特征的方式来更改
app.setAttribute('class', 'hdcms')

classList
如果对类单独进行控制使用 classList属性操作
node.classList.add	添加类名
node.classList.remove	删除类名
node.classList.toggle	切换类名
node.classList.contains	类名检测
node.classList.item	索引查找

使用style对象可以对样式属性单独设置，使用cssText可以批量设置行样式
node.style.cssText = "color:red;font-size:50px";

node.style.cssFloat是用来设置float方向的，值由"right","left" "none"

使用节点的style对象来设置行样式
可以这样：
node.style.fontSize = "50px";
或
node.style = "font-size:50px" //这个只能设置一种
多个单词的属性使用驼峰进行命名

也可以通过setAttribute改变style特征来批量设置样式
let app = document.getElementById('app')
app.setAttribute('style', `background-color:red;color:yellow;`)

使用window.getComputedStyle可获取所有应用在元素上的样式属性
函数第一个参数为元素
第二个参数为伪类
window.getComputedStyle只读

node.currentStyle 仅IE有效，也是只读

首先参考画布分为视口（窗口）与文档的含义
文档尺寸一般大于视口尺寸
当打开控制台后，视口尺寸相应变小

视口坐标需要知道滚动条位置才可以进行计算，有以下几种方式获取滚动位置
window.innerWidth	视口宽度	包括滚动条（不常用）
window.innerHeight	视口高度	包括滚动条（不常用）
document.documentElement.clientWidth	视口宽度	
document.documentElement.clientHeight	视口高度	

element.getBoundingClientRect	返回元素在视口坐标及元素大小，不包括外边距，width/height与offsetWidth/offsetHeight匹配	窗口坐标
element.getClientRects	行级元素每行尺寸位置组成的数组	
element.offsetParent	拥有定位属性的父级，或body/td/th/table	对于隐藏元素/body/html值为null
element.offsetWidth	元素宽度尺寸，包括内边距与边框和滚动条	
element.offsetHeight	元素高度尺寸，包括内边距与边框和滚动条	
element.offsetLeft	相对于祖先元素的X轴坐标	
element.offsetTop	相对于祖先元素的Y轴坐标	
element.clientWidth	元素宽度，不包含边框，只包含内容和内边距，行元素尺寸为0	
element.clientHeight	元素高度，不包含边框，只包含内容和内边距，行元素尺寸为0	
element.clientLeft	内容距离外部的距离，滚动条在左侧时包括滚动条尺寸	
element.clientTop	内容距离顶部的距离，滚动条在顶部时包括滚动条尺寸	
element.scrollWidth	元素宽度，内容+内边距+内容溢出的尺寸	
element.scrollHeight	元素高度，内容+内边距+内容溢出的尺寸	
element.scrollLeft	水平滚动条左侧已经滚动的宽度	
element.scrollTop	垂直滚动条顶部已经滚动的高度	


使用getBoundingClientRect获取元素矩形信息，信息都是相对于视口的：
元素的x，y
元素的top、right、bottom、left
元素的width和height

滚动条位置：
X：window.scrollX
Y：window.scrollY


element.getClientRect是返回一个collection，对于块级元素，就得到一个包含一个元素的collection，对于行级元素，若多行显示，则有多个矩形，它将它们全部放入collection中

坐标是相对于浏览器窗口
document.elementsFromPoint	返回指定坐标点所在的元素集合
document.elementFromPoint	返回指定坐标点最顶级的元素

滚动控制
window.pageXOffset	文档相对窗口水平滚动的像素距离	
window.pageYOffset	文档相对窗口垂直滚动的像素距离	
element.scrollLeft()	元素X轴滚动位置	
element.scrollTop()	元素Y轴滚动位置	
element.scrollBy()	按偏移量进行滚动内容	参数为对象，{top:垂直偏移量,left:水平偏移量,behavior:'滚动方式'}
element.scroll() 或 element.scrollTo()	滚动到指定的具体位置	参数为对象，{top:X轴文档位置,left:Y轴文档位置,behavior:'滚动方式'}
element.scrollLeft	获取和设置元素X轴滚动位置	这是属性，设置X轴文档位置
element.scrollTop	获取和设置元素Y轴滚动位置	这是属性，设置Y轴文档位置
element.scrollIntoView(bool)	定位到顶部或底部	参数为true元素定位到顶部，为false定位到窗口底部

window.pageXOffset	文档相对窗口水平滚动的像素距离	是window.scrollX别名
window.pageYOffset	文档相对窗口垂直滚动的像素距离	是window.scrollY别名

<button onclick="show()">后盾人</button>
<script>
  function show() {
    alert('houdunren.com')
  }
</script>

无法为事件类型绑定多个事件处理程序，下面绑定了多个事件处理程序，因为属性是相同的所以只有最后一个有效

使用setAttribute方法设置事件处理程序无效

addEventListener	添加事件处理程序
removeEventListener	移除事件处理程序
它的参数三为定制的选项对象：
once:true 只执行一次事件
capture:true/false 捕获阶段传播到该 EventTarget 时触发
passive:true listener 永远不会调用 preventDefault()

removeEventListener的第一个参数是事件名，第二个参数是要删除的回调函数

transtionend / DOMContentLoaded 等事件类型只能使用 addEventListener 处理

同一事件类型设置多个事件处理程序，按设置的顺序先后执行

也可以对未来添加的元素绑定事件

event：
大部分浏览器将事件对象保存到window.event中
有些浏览器会将事件对象做为事件处理程序的参数传递

e.preventDefault 和 ie的e.returnValue = false
e.stopPropagation 和 ie的e.cancelBubble = true

type	事件类型
target	事件目标对象，冒泡的父级通过该属性可以找到在哪个元素上执行了事件
currentTarget	当前执行事件的对象
timeStamp	事件发生时间
x	相对窗口的X坐标
y	相对窗口的Y坐标
clientX	相对窗口的X坐标
clientY	相对窗口的Y坐标
screenX	相对计算机屏幕的X坐标
screenY	相对计算机屏幕的Y坐标
pageX	相对于文档的X坐标
pageY	相对于文档的Y坐标
offsetX	相对于事件对象的X坐标
offsetY	相对于事件对象的Y坐标
layerX	相对于父级定位的X坐标
layerY	相对于父级定位的Y坐标
path	冒泡的路径
altKey	是否按了alt键
shiftKey	是否按了shift键
metaKey	是否按了媒体键
window.pageXOffset	文档参考窗口水平滚动的距离
window.pageYOffset	文档参考窗口垂直滚动的距离
#冒泡捕获

大部分事件都会冒泡，但像focus事件则不会

event.target 可以在事件中（包括父级元素中）得到事件目标元素即最底层的产生事件的对象
event.currentTarget == this 即当前执行事件的对象

如果同一类型事件绑定多个事件处理程序 event.stopPropagation() 只阻止当前的事件处理程序

event.stopImmediatePropagation() 阻止事件冒泡并且阻止相同事件的其他事件处理程序被调用

事件执行顺序为 捕获 > 事件目标 > 冒泡阶段执行，在向下传递到目标对象的过程即为事件捕获。事件捕获在实际使用中频率不高。

addEventListener通过设置第三个参数为true或{ capture: true } 在捕获阶段执行事件处理程序

事件代理
借助冒泡思路，我们可以不为子元素设置事件，而将事件设置在父级。然后通过父级事件对象的event.target查找子元素，并对他做出处理。

事件代理在为多个元素添加相同事件时很方便
事件代理使添加事件变得非常容易

使用onclick绑定的事件处理程序，return false 可以阻止默认行为
推荐使用event.preventDefault() 阻止默认行为

原生js的return false只阻止默认事件 

DOMContentLoaded	文档解析后不需要外部资源加载，只能使用addEventListener设置
window.onload	文档解析及外部资源加载后
window.beforeunload	文档刷新或关闭时
window.unload	文档卸载时
scroll	页面滚动时

window.unload事件在文档资源被卸载时执行，在beforeunload后执行

mouseenter和mouseleave不支持冒泡
mouseover和mouseout支持冒泡
mousemove移动

click	鼠标单击事件，同时触发 mousedown/mouseup
dblclick	鼠标双击事件
contextmenu	点击右键后显示的所在环境的菜单
mousedown	鼠标按下
mouseup	鼠标抬起时
mousemove	鼠标移动时
mouseover	鼠标移动时
mouseout	鼠标从元素上离开时
mouseenter	鼠标移入时触发，不产生冒泡行为
mosueleave	鼠标移出时触发，不产生冒泡行为
oncopy	复制内容时触发
scroll	元素滚动时，可以为元素设置overflow:auto; 产生滚动条来测试

which	执行mousedown/mouseup时，显示所按的键 1左键，2中键，3右键
clientX	相对窗口X坐标
clientY	相对窗口Y坐标
pageX	相对于文档的X坐标
pageY	相对于文档的Y坐标
offsetX	目标元素内部的X坐标
offsetY	目标元素内部的Y坐标
altKey	是否按了alt键
ctrlKey	是否按了ctlr键
shiftKey	是否按了shift键
metaKey	是否按了媒体键
relatedTarget	mouseover事件时从哪个元素来的，mouseout事件时指要移动到的元素。当无来源（在自身上移动）或移动到窗口外时值为null

mouseenter与mouseleave不会产生冒泡，即子元素和父元素（当前事件对象）来回移动时不产生事件

Keydown	键盘按下时，一直按键不松开时keydown事件会重复触发
keyup	按键抬起时

keyCode	返回键盘的ASCII字符数字
code	按键码，字符以Key开始，数字以Digit开始，特殊字符有专属名子。左右ALT键字符不同。
不同布局的键盘值会不同
key	按键的字符含义表示，大小写不同。不能区分左右ALT等。不同语言操作系统下值会不同
altKey	是否按了alt键
ctrlKey	是否按了ctlr键
shiftKey	是否按了shift键
metaKey	是否按了媒体键

focus	获取焦点事件
blur	失去焦点事件
element.focus()	让元素强制获取焦点
element.blur()	让元素失去焦点
change	文本框在内容发生改变并失去焦点时触发，select/checkbox/radio选项改变时触发事件
input	内容改变时触发，包括粘贴内容或语音输入内容都会触发事件
submit	提交表单

change：
当元素被:checked时（通过点击或者使用键盘）：<input type="radio"> 和 <input type="checkbox">；
当用户完成提交动作时（例如：点击了 <select>中的一个选项，从 <input type="date">标签选择了一个日期，通过<input type="file">标签上传了一个文件，等)；
当标签的值被修改并且失焦后，但并未进行提交（例如：对<textarea> 或者<input type="text">的值进行编辑后。）。